## Задание:
Вариант 3. 
*N пчел живет в улье, каждая пчела может собирать мед и сторожить улей (N > 3). Пчела не покинет улей, если кроме нее в нем нет других пчел. Каждая пчела приносит за раз одну порцию меда. Всего в улей может войти тридцать порций меда. Вини-Пух спит пока меда в улье меньше половины, но как только его становится достаточно, он просыпается и пытается достать весь мед из улья. Если в улье находится менее чем три пчелы, Вини-Пух забирает мед, убегает, съедает мед и снова засыпает. Если в улье пчел больше, они кусают Вини-Пуха, он убегает, лечит укус, и снова бежит за медом. Создать приложение, моделирующее поведение пчел и медведя. Осуществить балансировку, обеспечивающую циклическое освобождение улья от меда. Медведя и каждую из пчел представить отдельными процессами.*

## Входные данные
Корректными входными данными является целое число N (кол-во пчел, обитающих в улье)
Пример запуска:
```bash
gcc mark4/main4.c
./a.out 20
```


## Выходные данные
Программа ведет лог бесконечных событий (противостояния медеведя и пчел).
События: 
1) Пчела принесла ячейку меда
2) Медведь забрал мед
3) Медведь был ужален

## Алгоритм взаимодействия пчел и медведя
Медведь: находится в непрерывном поиске меда, захватывает семафор и выходит из спячки, когда улей заполнен хотя бы на половину, осуществляется проверка на кол-во пчел и опустошение в случае успеха или кулдаун в секунду иначе. Освобождает семафор.
Пчелы: также постоянно работают, процесс поиска меда занимает рандомное время (1-1.5 секунд) если есть место - доставляют мед. Работают с семафорами.

Более подробно в комментариях к методу `winny_process` и `bee_process`


## Оценка 4
В функции `main` происходит проверка входных данных, создание разделяемой памяти и инициализация семафора. Создаются процессы пчел и медведя, которые выполняют соответствующие функции `bee_process` и `winny_process`. Каждый процесс имеет доступ к разделяемой памяти и синхронизирует свой доступ к ней через семафор `sem_hive`
Функции `bee_process` и `winny_process` реализуют поведение пчел и медведя соответственно. 
Функция `handle_sigint` обрабатывает сигнал `SIGINT` и освобождает занятые ресурсы, включая разделяемую память и семафор. Также обработка высвобождения срабатывает, когда программа процедурно заканчивает свое выполнение (но, кажется, такое никогда не случится).

## Оценка 5
Логика аналогична работе на оценку 4, однако теперь семафор улья задается безымянным через метод `sem_init()`:
```c
sem_init(semaphore, 1, 1);
if (semaphore == SEM_FAILED) {
	exit_error("Smth wrong with sem_open call");
}
```

В данном методе `1` - значение, которым будет инициализирован счетчик семафора, обозначает, что семафор будет инициализирован как разблокированный.
`1` - флаг, определяющий, является ли семафор локальным для текущего процесса (0) или он может использоваться другими процессами (1).

## Оценка 6
Создание семафоров и разделенной памяти в системе Posix System V.
При запуске программы создается разделяемая память с помощью системного вызова `shmget()`, а затем с помощью системного вызова `shmat()` она линкуется с адресом виртуального адресного пространства процесса.

Cемафоры создаются с помощью системных вызовов `semget()` и `sem_open()`. 
Для контроля над данными используется структура`sembuf`, содержащая поля:
-   `sem_num` - номер семафора в массиве семафоров, к которому применяется операция;
-   `sem_op` - значение, на которое изменяется значение семафора;
-   `sem_flg` - флаги операции.
- 
Первая операция `semop(sem, &sem_op, 1);` ожидает, пока значение семафора не станет равным 0, после чего уменьшает его значение на 1. Функция `semop` применяет указанную операцию к массиву семафоров, на который ссылается параметр `sem`. В данном случае применяется только одна операция.
Вторая операция `semop(sem, &sem_op2, 1);` увеличивает значение семафора на 1 (`sem_op2.sem_op = 1`). Таким образом, значение семафора восстанавливается до исходного состояния.
