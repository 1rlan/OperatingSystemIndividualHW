# Общий отчет

## Задание:
Вариант 32. *Разработать программу, которая на основе анализа двух входных ASCII-строк формирует на выходе две другие строки. В первой из выводимых строк содержатся символы, которых нет во второй исходной строке. Во второй выводимой строке содержатся символы, отсутствующие в первой входной строке (разности символов). Каждый символ в соответствующей выходной строке должен встречаться только один раз.*

## Входные данные
*Корректными данными* является текстовый файл с двумя строками, разделенными знаком пробела, табуляции или переноса строки.

## Выходные данные
На выходе программа сохраняет две строки в текстовый файл, разделяя их знаком переноса строки. 

## Логика работы
Программа должна вывести две строки (разности). Разностью для строки N является неповторяющийся набор элементов, которые есть в строке N, но не в строке M. Например, возьмем строки  qwerty и qweasda:
В первом случае *qwe* cодержится во второй строке, а *rty* - нет. 
Второй случай - аналогичен, только символ *а* повторятся не будет.  Ответ - rty / ads.

## Алгоритм работы
#### Поиск разделителя
Первым делом, для нахождения начала второй строки (основываясь правиле на выходные данные выше) надо найти пробельный символ:
```C
// Проверка на 'пробельность'
int is_delimeter(char character) {
    return character == ' ' || character == '\t' || character == '\n';
}

int findDelimeter(char *string) {
	// Позиция потенциального пробела
    int delimeter = 0;

    // Если символ пробельный - останавлиаем хождения по строке
    while (!is_delimeter(str[delimeter])) {
        delimeter++;
    }

    return delimeter
}
```

#### Заполнение словаря
За основу asсii словаря были взяты первые 256 символов. Мы итерируемся по каждоый строке и заполняем кол-во вхождений каждого символа в импровизированный словарь, где ключ, это код ascii символа, а значение - количество вхождений символа в строку.
```C
void subtracting(char *string, char *ans1, char *ans2) {
    int delimeter = find_delimeter(string);
	int dict1[256] = {0};
    int dict2[256] = {0};

    for (int i = 0; i < delimeter; i++) {
        dict1[(int) string[i]]++;
    }

    for (int i = delimeter + 1; string[i + 1] != '\0'; i++) {
        dict2[(int) string[i]]++;
    }
	...
}
```

#### Вычитание строк
Для поиска разности осуществляется итерация по словарю. Если символ существует в строке n (dict[i] > 0), но не существует в строке m (dict[i] == 0), то он подходит под понятие разности. 
```C
void subtracting(char *string, char *ans1, char *ans2) {
	...

    int k1 = 0, k2 = 0;
    for (int i = 0; i < 256; i++) {
        if (dict1[i] > 0 && dict2[i] == 0) {
            ans1[k1++] = (char) i;
        }

        if (dict2[i] > 0 && dict1[i] == 0) {
            ans2[k2++] = (char) i;
        }
    }
    ans1[k1] = '\0';
    ans2[k2] = '\0';
}
```

